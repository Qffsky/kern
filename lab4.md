# Лаба 4

# Table of contents

- [Лаба 4](#лаба-4)
- [Table of contents](#table-of-contents)
  - [Задание 1](#задание-1)
  - [Задание 2](#задание-2)
  - [Задание 3](#задание-3)
  - [Задание 4](#задание-4)
  - [Задание 5](#задание-5)
  - [Задание 6](#задание-6)
  - [Задание 7](#задание-7)


## Задание 1

Чтобы работать с низкоуровневой памятью контролллера MC146818, необходимо воспользоваться функциями:

1) Для **чтения**

```c
uint8_t inb(int port);
```
Для дальнейшего изучения:

```
man inb
```

2) Для **записи**

```c
void outb(int port, uint8_t data);
```

Для дальнейшего изучения:
```
man outb
```


Аргумент **port** отвечает за номер порта, с которым мы работаем. Их всего 2: **CMOS_CMD (0x070)** и **CMOS_DATA (0x071)**. Для указания, какой мы регистр хотим считать или записать, необходимо послать на **port == CMOS_CMD** номер регистра, с которым собираемся работать, затем уже через **port == CMOS_DATA** читать/писать данные. После доступа к регистру через **port == CMOS_DATA**, номер регистра, с которым мы работали, сбрасывается, поэтому необходимо каждый раз указывать его заново.

<br />

Для дальнейшего изучения:

- [Вики по NMI](https://wiki.osdev.org/Non_Maskable_Interrupt)

- [Вики по CMOS](https://wiki.osdev.org/CMOS)


Для корректной работы контроллера необходимо отключать **NMI - Non Maskable Interrupt**. Причина этому следует из нескольких предпосылок:

1. **port == CMOS_CMD** (0x070) также принимает NMI, то есть этот порт разделен между CMOS и NMI.
2. При записи в **port == CMOS_CMD** CMOS RTC ***ОЖИДАЕТ*** обращения к **port == CMOS_DATA**, иначе он переходит в undefined state!

За включение/отключение NMI отвечают следующие функции, определённые в **inc/x86.h**

```c
static inline void __attribute__((always_inline))
nmi_enable(void) {
    outb(CMOS_CMD, inb(CMOS_CMD) & ~CMOS_NMI_LOCK);
}

static inline void __attribute__((always_inline))
nmi_disable(void) {
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
}
```

<br />

## Задание 2

**Важно:** QEMU реализовывает контроллер MC146818, однако ее реализация неверная: в ней указан размер CMOS памяти 128Б, хотя в даташите указан размер 64Б.

**Даташит:** [MC146818](datasheets/MC146818.pdf)

В данном задании нужно просто вывести все в правильном формате. В CMOS находится 64Б.

<br />

**Пара уточнений:**

- В коде лабы присутствуют дефайны **CMOS_START == 0xE** и **CMOS_SIZE == 50**.
Возможно, при выводе дампа памяти нужно использовать именно их (но таким образом выведется только **User RAM** (т.е. байты с 14 по 63 (считаем от 0)).

- Кроме того, если говорить про QEMU, то можно, вообще говоря, вывести 128 байт (как и прочитать или записать в любой из них).
Однако стоит понимать, что на реальном устройстве это может не сработать, а может привести к чему-то неожиданному.

<br />

Строчку ассерта для входа в монитор:
```C
assert(false);
```
нужно добавить после инициализации rtc, но до инициализации первого env (до функции env_init). Примерно 109 строчка в **kern/init.c**

<br />

## Задание 3

Для инициализации часов RTC необходимо в функции **rtc_timer_init()** реализовать включение в контроллере **MC146818** прерывания **IRQ 8**.

Для дальнейшего изучения:

- [Вики по RTC](https://wiki.osdev.org/RTC)

Это делается установкой бита **RTC_PIE == 0x40** в значении регистра часов B.
Для удобства работы с регистрами в **kern/klock.h** определены дефайны:
```c
#define RTC_AREG 0x0A
#define RTC_BREG 0x0B
#define RTC_CREG 0x0C
#define RTC_DREG 0x0D
```

Чтение или запись в регистры нужно писать, используя ранее написанные функции:
```c
uint8_t cmos_read8(uint8_t reg);
void cmos_write8(uint8_t reg, uint8_t value);
```

В функции **rtc_check_status()** необходимо просто прочитать значение регистра часов С.


## Задание 4

**Пара замечаний:**

- Это задание лучше делать после 5-ого и 6-ого. **Настоятельно** рекомендуется.

- В чем заключается архитектурная особенность JOS'а, про которую пишется в тексте лабы, мы не особо поняли.

В 5-ом задании мы настраиваем обработку прерываний. Гипотетически, аппаратное прерывание может прийти в любой момент, пока выполняется код ядра (что, вообще говоря, не должно являться проблемой). Если говорить про более реалистичные примеры, то потенциально прерывание от RTC может прийти в момент, когда мы их включили на контроллере, но еще не настроили таблицу прерываний (в JOS'e на момент 4 лабы это происходит именно в такой последовательности. Возможно, это и есть та самая архитектурная особенность).

Поэтому нам надо каждый раз, когда управление переходит на код ядра, маскировать аппаратные прерывания посредством ассемблерной инструкции **cli** (Clear Interrupt Flag) **(если, конечно, прерывания уже не были замаскированы, например, процессором самостоятельно)**.

Это происходит в 3 случаях, и код каждого из них находится в **kern/entry.S**:

- На точке входа ядра, в функции **entry**

- При передаче пользовательским приложением управление ядру, в функции **sys_yield**

- При завершении выполнения пользовательского приложения, в функции **sys_exit**

В начале каждой из выше перечисленных функций требуется вставить команду **cli**, если она там еще не стоит.


**На этом можно было бы закончить, но...**

Если поставить **cli** в начале функции **sys_yield**, то мы сбросим флаг **IF** в регистре **RFLAGS**, который сохраняется в **trapframe** только потом в функции **save_trapframe_syscall**. Когда же планировщик захочет вернуться к выполнению данного процесса, кажется, он возьмет из сохранненого **trapframe** испорченный регистр (испорченный в плане сброшенного бита **IF**, который не должен был быть сброшен) и, следовательно, прерывания на данный процесс приходить больше не должны.

Однако этого не произойдет, потому что сразу после метки **save_trapframe** (к которой неминуемо перейдет управление после **save_trapframe_syscall**) стоят две странные строчки (первая из которых комментарий, а вторая устанавливает **IF** в сохраненном **RFLAGS**):
```asm
# Guard to avoid hard to debug errors due to cli misusage.
orl $FL_IF, saved_rflags(%rip)
```

Это есть ничто иное, как "защита" в коде ядра от неправильного использования **cli**. По идее, этих строчек быть не должно, и тогда правильным решением было бы поставить **cli** не после метки **sys_yield** (т.е. поставить не до сохранения **RFLAGS**), а после сохранения **RFLAGS** (т.е. сразу, например, после метки **save_trapframe**). Однако в таком случае прерывание может прийти после начала выполнения **sys_yield**, но до инструкции **cli** (которая должна в таком случае стоять сразу после метки **save_trapframe**)). А это в свою очередь значит, что произошло прерывание во время выполнения кода ядра.

Как минимум, это противоречит условию лабы. А вообще, это, возможно, сломает логику планировщика. Честно говоря, я тут заебался уже думать, что потенциально может из-за подобного произойти, но допускаю, что можем потерять данные **trapframe** (и, возможно, это является архитектурной особенностью). А может и вообще все охуенно будет и зря мы переживали.

Тем не менее, в лабе не просят ничего удалять, так что скорее всего правильным ходом будет сделать так как написано до заголовка **"на этом можно было бы закончить"**. Однако еще более правильным будет прочитать то, что написано вплоть до сюда, и продумать все возможные случаи.

**P.S.** Прерывания мы отключаем во время выполнения кода ядра, а включаем обратно во время выполнения кода пользовательского процесса. Это происходит в **env_pop_tf**: ассемблерная вставка в данной функции сперва перемещает значения некоторых регистров со стека (из лежащего на стеке **trapframe**), а затем командой **iretq** вытаскивает со стека регистры **RIP, CS, RFLAGS** (в **RFLAGS** установлен флаг **IF**: во-первых, он устаналивается при создании процесса (в функции **env_alloc**), а во-вторых при помощи странных двух строчек, указанных выше, восстанавливается, если мы его испортили при сохранении) и продолжает выполнение кода пользовательского процесса по адресу **CS:RIP**.


## Задание 5

В функции **i386_init** в файле **kern/init.c** происходит инициализация контроллера прерываний **PIC (Programmable Interrupt Controller)** и инициализация часов **RTC**.

Для дальнейшего изучения:

- [Вики по PIC](https://wiki.osdev.org/8259_PIC)

Для того, чтобы на процессор могли доходить прерывания, вызванные часами RTC, мы должны размаскировать на контроллере прерываний **PIC** линию **IRQ_CLOCK**.

Чтобы реализовать данное действие, надо в функции **rtc_timer_pic_interrupt** вызвать функцию **pic_irq_unmask** с параметром **mask == IRQ_CLOCK**.

Прототип функции **pic_irq_unmask**, определенный в файле **kern/picirq.h**:
```c
void pic_irq_unmask(uint8_t mask);
```

Для дальнейшего изучения:

- [Вики по IDT](https://wiki.osdev.org/Interrupt_Descriptor_Table)

- [Отдельно на Gate Descriptor](https://wiki.osdev.org/Interrupt_Descriptor_Table#Gate_Descriptor)

Чтобы процессор смог обработать наше прерывание, мы должны в таблице прерываний **IDT** в нужный индекс записать дескриптор шлюза прерывания **(interrupt gate descriptor)**.
Для удобства "создания" дескриптора в коде ядра есть дефайн **GATE**:
```c++
#define GATE(istrap, sel, off, dpl)                           \
    (struct Gatedesc) {                                       \
        .gd_off_15_0 = (uint64_t)(off)&0xFFFF,                \
        .gd_ss = (sel),                                       \
        .gd_ist = 0,                                          \
        .gd_rsv1 = 0,                                         \
        .gd_type = (istrap) ? STS_TG64 : STS_IG64,            \
        .gd_s = 0,                                            \
        .gd_dpl = (dpl),                                      \
        .gd_p = 1,                                            \
        .gd_off_31_16 = ((uint64_t)(off) >> 16) & 0xFFFF,     \
        .gd_off_32_63 = ((uint64_t)(off) >> 32) & 0xFFFFFFFF, \
        .gd_rsv2 = 0,                                         \
    }
```

Также в **inc/memlayout.h** определены полезные дефайны, содержащие номера дескрипторов памяти ядра (это нужно, когда создаете дескриптор шлюза прерывания), и полезные комментарии для понимания устройства памяти ядра на данный момент.

При создании дескриптора понадобится указать адрес функции обработчика прерывания. В нашем случае это функция **clock_thdlr**, определенная в ассемблерном файле **kern/trapentry.S**. По дефолту ее прототип не указан ни в **kern/trap.c**, ни в **kern/trap.h**. Поэтому придется добавить его самостоятельно в один из ранее указанных файлов:
```c
void clock_thdlr(void);
```

В дальнейших лабораторных это придется сделать и для обработчиков, которые появятся в будущем.

## Задание 6

Сначала стоит узнать о том, что происходит с процессором, когда приходит прерывание.

Это достаточно подробно описано в достаточно старой [статье некоего fat_crocodile](http://fat-crocodile.narod.ru/protected/05_external_interrupts.html). Тем не менее, важно прочитать, чтобы иметь понимание о том, что будет происходить дальше.

Когда **RTC** сгенерировало прерывание, оно приходит на контроллер прерываний, откуда на процессор, где последний в свою очередь передает управление на обработчик прерывания, указанный в соответствующем дескрипторе в таблице **IDT**. Однако прямо перед этим процессор сохранит на стеке регистры **SS, RSP, RFLAGS, CS, RIP**, а также замаскирует прерывания (сбросит флаг **IF** в **RFLAGS**, но уже после сохранения старого **RFLAGS** на стек).

В данной лабе управление перейдет на функцию-обработчик **clock_thdlr**, которая в свою очередь первым делом вызывает **save_trapframe_trap**, определенную в **kern/entry.S**. Говоря упрощенно, **save_trapframe_trap** сохранит на стек ядра **trapframe** прерванного процесса.

Затем **clock_thdlr** записывает в поле **tf_trapno** трепфрейма, лежащего в данный момент на стеке, номер обрабатываемого прерывания (**IRQ_OFFSET + IRQ_CLOCK**) и передает управление функции **trap**, а та в свою очередь после некоторых манипуляций вызовет **trap_dispatch**.

Как раз в функции **trap_dispatch** и нужно дописать завершение обработки нашего прерывания. Оно заключается в чтении регистра **C** контроллера **RTC** и отправке сигнала **EOI (End Of Interrupt)** на контроллер прерываний **PIC**.

Смысл в чтении регистра **C** прост: после каждого чтения данного регистра в нем автоматически сбрасывается бит, блокирующий прерывания (подробнее можно прочитать в даташите).

Отправка же сигнала **EOI** позволяет контроллеру прерываний посылать новые **IRQ** на процессор.

## Задание 7

Чтобы изменить частоту генерации прерываний, необходимо изменить младшие 4 бита регистра **A** контроллера **RTC** (подробнее в даташите). В **kern/kclock.h** имеется полезный дефайн, позволяющий установить биты таким образом, чтобы прерывания генерировались раз в полсекунды:
```c
#define RTC_500MS_RATE                0x0F
```

