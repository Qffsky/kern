# Лаба 4

# Table of contents

1.  [Задание 1](#задание-1)
2.  [Задание 2](#задание-2)
3.  [Задание 3](#задание-3)
4.  [Задание 4](#задание-4)
5.  [Задание 5](#задание-5)
6.  [Задание 6](#задание-6)
7.  [Задание 7](#задание-7)


## Задание 1

Чтобы работать с низкоуровневой памятью контролллера MC146818A, необходимо воспользоваться функциями:

**ВАЖНО** : qemu реализовывает дргуой контроллер MC146818 вместо указанного, при этом реализация неверная, в ней указан размер CMOS памяти 128Б, хотя в даташитах указан размер 64Б.

Даташиты: [MC146818A](/home/stepa/Desktop/datasheets/mc146818a.pdf), [MC146818](/home/stepa/Desktop/datasheets/mc146818a.pdf)  


1) Для **чтения**

```
    unsigned char inb(unsigned short int port);
```
Для дальнейшего изучения:

     man inb

2) Для **записи**

```
    void outb(unsigned char value, unsigned short int port);
```

Для дальнейшего изучения:

    man outb

Переменная **port** отвечает за номер порта, с которым мы работаем. Их всего 2: CMOS_CMD(0x070) и CMOS_DATA (0x071). Для управления тем, какой мы регистр хотим считать или записать, необходимо послать на **port == CMOS_CMD** значение регистра, с которым хотим работать, затем уже через **port == CMOS_DATA** читать/писать данные. После доступа к регистру через **port == CMOS_DATA**, значение регистра, с которым работаем сбрасывается, поэтому необходимо каждый раз указывать его заново.

Для дальнейшего изучения:

- [Вики по NMI](https://wiki.osdev.org/Non_Maskable_Interrupt)

- [Вики по CMOS](https://wiki.osdev.org/CMOS)


Для корректной работы контроллера необходимо отключать NMI - Non Maskable Interrupt. Причина этому следует из нескольких предпосылок:

1. **port == CMOS_CMD**(0x070) также принимает NMI, то есть этот порт разделен между CMOS и NMI.
2. При записи в **port == CMOS_CMD** CMOS RTC ***ОЖИДАЕТ*** обращения к **port == CMOS_DATA**, иначе он переходит в undefined state!!!

За включение/отключение NMI отвечают следующие команды, определённый в inc/x86.h

```
static inline void __attribute__((always_inline))
nmi_enable(void) {
    outb(CMOS_CMD, inb(CMOS_CMD) & ~CMOS_NMI_LOCK);
}

static inline void __attribute__((always_inline))
nmi_disable(void) {
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
}
```

## Задание 2

Нужно просто вывести все с правильным форматом. В CMOS находится 64Б (64 == 0x4).

**assert(false);** нужно добавить после инициализации rtc, но до инициализации первого env(примерно 109 строчка в init.c) 

## Задание 3

## Задание 4

## Задание 5

## Задание 6

## Задание 7


