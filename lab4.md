# Лаба 4

# Table of contents

- [Лаба 4](#лаба-4)
- [Table of contents](#table-of-contents)
  - [Задание 1](#задание-1)
  - [Задание 2](#задание-2)
  - [Задание 3](#задание-3)
  - [Задание 4](#задание-4)
  - [Задание 5](#задание-5)
  - [Задание 6](#задание-6)
  - [Задание 7](#задание-7)


## Задание 1

Чтобы работать с низкоуровневой памятью контролллера MC146818, необходимо воспользоваться функциями:

1) Для **чтения**

```c
uint8_t inb(int port);
```
Для дальнейшего изучения:

```
man inb
```

2) Для **записи**

```c
void outb(int port, uint8_t data);
```

Для дальнейшего изучения:
```
man outb
```


Аргумент **port** отвечает за номер порта, с которым мы работаем. Их всего 2: **CMOS_CMD (0x070)** и **CMOS_DATA (0x071)**. Для указания, какой мы регистр хотим считать или записать, необходимо послать на **port == CMOS_CMD** номер регистра, с которым собираемся работать, затем уже через **port == CMOS_DATA** читать/писать данные. После доступа к регистру через **port == CMOS_DATA**, номер регистра, с которым мы работали, сбрасывается, поэтому необходимо каждый раз указывать его заново.

<br />

Для дальнейшего изучения:

- [Вики по NMI](https://wiki.osdev.org/Non_Maskable_Interrupt)

- [Вики по CMOS](https://wiki.osdev.org/CMOS)


Для корректной работы контроллера необходимо отключать **NMI - Non Maskable Interrupt**. Причина этому следует из нескольких предпосылок:

1. **port == CMOS_CMD** (0x070) также принимает NMI, то есть этот порт разделен между CMOS и NMI.
2. При записи в **port == CMOS_CMD** CMOS RTC ***ОЖИДАЕТ*** обращения к **port == CMOS_DATA**, иначе он переходит в undefined state!

За включение/отключение NMI отвечают следующие функции, определённые в **inc/x86.h**

```c
static inline void __attribute__((always_inline))
nmi_enable(void) {
    outb(CMOS_CMD, inb(CMOS_CMD) & ~CMOS_NMI_LOCK);
}

static inline void __attribute__((always_inline))
nmi_disable(void) {
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
}
```

<br />

## Задание 2

**Важно:** QEMU реализовывает контроллер MC146818, однако ее реализация неверная: в ней указан размер CMOS памяти 128Б, хотя в даташите указан размер 64Б.

**Даташит:** [MC146818](datasheets/MC146818.pdf)

В данном задании нужно просто вывести все в правильном формате. В CMOS находится 64Б.

<br />

**Пара уточнений:**

- В коде лабы присутствуют дефайны **CMOS_START == 0xE** и **CMOS_SIZE == 50**.
Возможно, при выводе дампа памяти нужно использовать именно их (но таким образом выведется только **User RAM** (т.е. байты с 14 по 63 (считаем от 0)).

- Кроме того, если говорить про QEMU, то можно, вообще говоря, вывести 128 байт (как и прочитать или записать в любой из них).
Однако стоит понимать, что на реальном устройстве это может не сработать, а может привести к чему-то неожиданному.

<br />

Строчку ассерта для входа в монитор:
```C
assert(false);
```
нужно добавить после инициализации rtc, но до инициализации первого env (до функции env_init). Примерно 109 строчка в **kern/init.c**

<br />

## Задание 3

Для инициализации часов RTC необходимо в функции **rtc_timer_init()** реализовать включение в контроллере **MC146818** прерывания **IRQ 8**.

Для дальнейшего изучения:

- [Вики по RTC](https://wiki.osdev.org/RTC)

Это делается установкой бита **RTC_PIE == 0x40** в значении регистра часов B.
Для удобства работы с регистрами в **kern/klock.h** определены дефайны **RTC_AREG == 0x0A, RTC_BREG == 0x0B, RTC_CREG == 0x0C, REC_DREG == 0x0D**.

Чтение или запись в регистры нужно писать, используя ранее написанные функции:
```c
uint8_t cmos_read8(uint8_t reg);
void cmos_write8(uint8_t reg, uint8_t value);
```

В функции **rtc_check_status()** необходимо просто прочитать значение регистра часов С.


## Задание 4

**Пара замечаний:**

- Это задание лучше делать после 5-ого.

- В чем заключается архитектурная особенность JOS'а, про которую пишется в тексте лабы, мы не особо поняли.

В 5-ом задании мы настраиваем обработку прерываний. Гипотетически, аппаратное прерывание может прийти в любой момент, пока выполняется код ядра. Если говорить про более реалистичные примеры, то потенциально прерывание от RTC может прийти в момент, когда мы их включили на контроллере, но еще не настроили таблицу прерываний (в JOS'e на момент 4 лабы это происходит именно в такой последовательности. Возможно, это и есть та самая архитектурная особенность).

Поэтому нам надо каждый раз, когда управление переходит на код ядра, маскировать аппаратные прерывания посредством ассемблерной инструкции **cli** (Clear Interrupt Flag).

Это происходит в 3 случаях, и код каждого из них находится в **kern/entry.S**:

- На точке входа ядра, в функции **entry**

- При передаче пользовательским приложением управление ядру, в функции **sys_yield**

- При завершении выполнения пользовательского приложения, в функции **sys_exit**

В начале каждой из выше перечисленных функций требуется вставить команду **cli**, если она там еще не стоит.

## Задание 5



## Задание 6

## Задание 7


